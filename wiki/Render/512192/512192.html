<div class="wikidoc"><b>Project Description</b><br />This is a partial port of the Perl Geo&#58;&#58;StreetAddress&#58;&#58;US CPAN module to C&#35;. The goal is to take a US address as a single-line string and parse it out into its component pieces to accelerate data entry and import.<br /><br />The class <b>AddressParser</b> takes a semi-structured address input as a single <b>String</b> and returns it parsed into an <b>AddressParseResult</b> instance. It includes some unit tests and a console application so that you can play around with it:<br /><br /><img src="http://download-codeplex.sec.s-msft.com/Download?ProjectName=usaddress&DownloadId=318319" alt="Capture.PNG" title="Capture.PNG" /><br />
<h2>Where this came from</h2>
This code is a partial port of the <a href="http://search.cpan.org/~timb/Geo-StreetAddress-US-1.03/US.pm">Geo::StreetAddress:US</a> Perl module from CPAN written by Schuyler D. Erle. In his case, he wrote it as part of the great <a href="http://geocoder.us/">geocoder.us</a> service that provides free geocoding for US addresses (with some reasonable rate limiting and restrictions for commercial use).<br /><br />As such, the original Perl module has the ability to parse intersections &quot;Main St &amp; 1st St, Anytown, VA 12345&quot; and partial addresses. I didn&#39;t port this functionality over to C# for reasons explained below.<br />
<h2>What this is for</h2>
In my case, <b>I wanted to be able to provide a single textbox on a Web page for users to paste in shipping addresses</b> and be able to parse out the address correctly (in a large percentage of cases, at least) into the individual street / city / state / zip fields for database storage and submission to third-party APIs. Instead of having to tab between four different fields, the user can just paste in the address from Word or another Web page and off they go. (If the address parsing fails, then I pop up an AJAX dialog that shows the individual form fields.) I wanted to be able to do this without having to worry about subscribing to, paying for, and integrating with a third-party CASS-certified address verification API. In other words, it&#39;s meant to provide a convenience for users when it comes to <b>data entry</b>, <i>not</i> data validation.<br /><br />As a result of this difference in intended use (geocoding vs parsing), I <b>neglected to port some functionality</b> of the original Perl module (intersections and partial addresses) and <b>added some additional functionality</b> (recognizing PO boxes and military addresses as well as correcting secondary unit abbreviations).<br /><br />The class could also be useful if <b>you have a large list of unstructured address input</b> and you want some help in getting everything merged into a &quot;mostly correct&quot; set of delimited fields without actually paying for a CASS-certified service.<br />
<h2>What this is NOT for</h2>
This does <i>not</i> provide CASS-certified address correction, and it does <i>not</i> verify a delivery point. It does not tell if you an address is correct and/or deliverable. The USPS address database costs real money and is updated monthly, and this doesn&#39;t depend on that. <br /><br />As such, you can pass in &quot;321 Cheese Street Apt A Sillytown Virginia 12345&quot;, and it will happily spit back &quot;321 CHEESE ST APT A; SILLYTOWN VA 12345&quot;. It does not know whether or not an address exists.<br /><br />As such, it cannot provide perfect parse results in all cases, although an effort has been made to cover common ones, such as grid-style addresses, Queens-style addresses, post office boxes, and military addresses. But without a list of valid delivery points, it won&#39;t be able to decide if &quot;403D S St&quot; should be &quot;403 SOUTH ST APT D&quot; or &quot;403 D S ST&quot;. This is also particularly common when users add nonsense to the street line.<br />
<h2>How it works</h2>
Like the original Perl version, the <b>AddressParser</b> class solves the problem by building up a fantastically giant regular expression (&quot;now we have two problems&quot;) based on the common abbreviations and formats that a US address can be in. Calling <b>ParseAddress()</b> simply runs a match against that regex and returns any of its named captures as properties in an <b>AddressParseResult</b> instance.<br /><br />It is certainly not magic. Without a list of valid delivery points, it&#39;s impossible for it to know the true intent in some cases, especially if you hand it addresses where users have typed crap in the street line. (&quot;123 Main St Door Code # 438&quot; would result in it thinking the street is named &quot;MAIN DOOR CODE&quot;, for example, and without a list of valid streets, it&#39;s not going to know that &quot;DOOR CODE&quot; should be part of a leftovers field instead of the street name.)<br /><br /><b>Make sure that you can accept these limitations in your intended use case.</b> I have posted it because I feel that it&#39;s something that people could still use in a great many products, and that porting it to C# makes it a bit more accessible to many more people.</div><div class="ClearBoth"></div>